# CLRS

## TLDR;
*I'll stop procrastinating and study.*

## Summary
In simple terms, I will save notes and programs I solve as I read this book. Research and links to external content will also be shared.

## Introduction
After many tries of trying to read CLRS the coveted book for competitive programmers and computer science enthusiasts in general, I have decided that enough was enough. Before my university education ends I will conquer CLRS.

With around 8 months remaining until my graduation I believe that I can conquer this book within a month or two with enough education. After completing 2 internships @ Google (Chrome-Security team and GCP-Network-Reachability team) and 1 Microsoft internship remaining (VSCode-Compilers team) in this summer, along with my job at a startup as a backend-dev && dev-ops && security engineer @ Airtm... I believe that I have procrastinated enough and that my current experiences in coding and solving problems would give me an advantage in better understanding the materials (at least more than the previous attempts).

## Crisis
It is also important to note that this project was started since COVID-19 is finally attacking everyone around the world. Because of this I have received home-office along with home-school in order to fight this pandemic. Whilst being alone and as I started to get my shit together I was more and more irritated by my attitude and started to complete this task.

## Tools
Since this is a very ambitious project, I will also be using very ambitious tools. The following sections explain the program and simple commands to run/visualize or setup the environment I currently have (at the time of writing).

### Markdown
For markdown visualization I would recommend the use of ```grip```.

I personally have downloaded grip through ubuntu's package manager by running ```sudo apt install grip```.
To run ```grip```, just run ```grip README.md``` and it should be available in *localhost:6419*...

### Basic texts
For basic texts, I will be using ```groff```. If you want more information I would recommend a simple tutorial by Luke Smith in the following link:
 https://www.youtube.com/watch?v=w8EKH_fjmXA

```groff/troff``` usually comes along with most *nix distros. However I have noticed that the ```groff``` included in my Ubuntu package-manager is not the widely-used version. Therefore, if the following command does not work, you will have to run ```sudo apt install groff``` in order to get the latest version.

For the mathematical equation display format, we utilize ```eqn``` which also comes along in most *nix systems. Because of this we will use the ```-e``` flag when running ```groff```.

```groff -e -ms ./test.ms -T pdf > test.pdf``` should output a test pdf file.

### Progress

In progress:
Chapter 22 - Elementary Graph Algorithms

- [x] Chapter 1	   - The Role of Algorithms in Computing
- [ ] Chapter 2    - Getting Started
- [ ] Chapter 3    - Growth of Functions
- [ ] Chapter 4    - Divide-and-Conquer
- [ ] Chapter 5    - Probabilistic Analysis and Randomized Algorithms
- [ ] Chapter 6    - Heapsort
- [ ] Chapter 7    - Quicksort
- [ ] Chapter 8    - Sorting in Linear Time
- [ ] Chapter 9    - Medians and Order Statistics
- [ ] Chapter 10   - Elementary Data Structures
- [ ] Chapter 11   - Hash Tables
- [ ] Chapter 12   - Binary Search Trees
- [ ] Chapter 13   - Red-Black Trees
- [ ] Chapter 14   - Augmenting Data Structures
- [ ] Chapter 15   - Dynamic Progamming
- [ ] Chapter 16   - Greedy Algorithms
- [ ] Chapter 17   - Amortized Analysis
- [ ] Chapter 18   - B-Trees
- [ ] Chapter 19   - Fibonacci Heaps
- [ ] Chapter 20   - van Embe Boas Trees
- [ ] Chapter 21   - Data Structures for Disjoint Sets
- [ ] Chapter 22   - Elementary Graph Algorithms
- [ ] Chapter 23   - Minimum Spanning Trees
- [ ] Chapter 24   - Single-Source Shortest Paths
- [ ] Chapter 25   - All-Pairs Shortest Paths
- [ ] Chapter 26   - Maximum Flow
- [ ] Chapter 27   - Multithreaded Algorithms
- [ ] Chapter 28   - Matrix Operations
- [ ] Chapter 29   - Linear Programming
- [ ] Chapter 30   - Polynomials and the FFT
- [ ] Chapter 31   - Number-Theoretic Algorithms
- [ ] Chapter 32   - String Matching
- [ ] Chapter 33   - Computational Geometry
- [ ] Chapter 34   - NP-Completeness
- [ ] Chapter 35   - Approximation Algorithms
